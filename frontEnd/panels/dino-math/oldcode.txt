import { callAPI, submitGameResult } from '../../js/utils.js';

function loadStyles() {
  if (!document.querySelector('link[data-panel="dino-math"]')) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = './panels/dino-math/style.css';
    link.setAttribute('data-panel', 'dino-math');
    document.head.appendChild(link);
  }
}

export async function mount(container) {
  if (!container) return;
  loadStyles();

  container.innerHTML = '<div class="loading">‚è≥ ƒêang t·∫£i d·ªØ li·ªáu Kh·ªßng Long...</div>';

  // 1. G·ªçi API l·∫•y level lo·∫°i 'dino'
  const res = await callAPI('/games/levels/dino');
  
  if (!res || !res.success) {
      container.innerHTML = '<div class="panel-error">‚ùå L·ªói t·∫£i d·ªØ li·ªáu. B·∫°n ƒë√£ ch·∫°y l·ªánh SQL ch∆∞a?</div>';
      return;
  }

  renderLevelList(container, res.data);
}

function renderLevelList(container, levels) {
    let html = `
        <div class="dino-panel">
            <div class="game-container" style="display:block; text-align:center; padding-top:40px; height:auto; min-height:400px;">
                <h1 style="color:#4CAF50; font-size: 2rem; margin-bottom:10px;"><i class="fas fa-dragon"></i> Kh·ªßng Long Gi·ªèi To√°n</h1>
                <p style="margin-bottom:30px; color:#555;">Gi√∫p kh·ªßng long v∆∞·ª£t ch∆∞·ªõng ng·∫°i v·∫≠t b·∫±ng c√°ch gi·∫£i to√°n!</p>
                <div style="display:grid; gap:15px; padding:0 20px;">
    `;

    levels.forEach(level => {
        // config: { speed: 5, ops: ['+', '-'] }
        html += `
            <div class="level-card" id="btn-play-${level.level_id}"
                 style="background:#f1f8e9; padding:20px; border-radius:12px; border:2px solid #81c784; cursor:pointer; transition:all 0.2s; text-align:left; display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <strong style="font-size:18px; color:#2e7d32;">C·∫•p ƒë·ªô ${level.level_number}: ${level.title}</strong>
                    <div style="font-size:14px; color:#558b2f; margin-top:5px;">${level.description}</div>
                </div>
                <button style="background:#4CAF50; color:white; border:none; padding:10px 20px; border-radius:25px; cursor:pointer; font-weight:bold;">Ch∆°i ngay ‚ñ∂</button>
            </div>
        `;
    });

    html += '</div></div></div>';
    container.innerHTML = html;

    // G·∫Øn s·ª± ki·ªán click
    levels.forEach(l => {
        const btn = document.getElementById(`btn-play-${l.level_id}`);
        if(btn) btn.addEventListener('click', () => startGame(container, l));
    });
}

// --- LOGIC GAME CH√çNH ---
function startGame(container, level) {
    // Config t·ª´ DB
    const GAME_SPEED = level.config.speed || 6;
    const OPS = level.config.ops || ['+', '-'];

    container.innerHTML = `
    <div class="dino-panel">
      <div class="game-container">
          <div class="hud">
              <button id="btn-back-menu" style="margin-right:15px; background:#fff; border:2px solid #333; cursor:pointer; padding:5px 10px; font-weight:bold;">‚¨Ö Tho√°t</button>
              <span>ƒêi·ªÉm: <span id="score">0</span></span>
              <div id="lives-container" class="lives-wrapper" style="margin-left:15px; color:red;"></div>
          </div>
          <canvas id="gameCanvas" width="800" height="300"></canvas>

          <div id="start-screen" class="overlay">
              <h1 style="color:white; text-shadow:2px 2px #000;">Nh·∫•n SPACE ho·∫∑c CLICK ƒë·ªÉ ch·∫°y!</h1>
              <p style="color:white;">C·∫©n th·∫≠n x∆∞∆°ng r·ªìng nh√©!</p>
          </div>
          
          <div id="game-over-screen" class="overlay hidden">
              <h1 style="color:#ff5252; background:white; padding:5px 20px; border-radius:10px;">THUA R·ªíI!</h1>
              <p style="color:white; font-size:20px; margin:10px 0;">ƒêi·ªÉm c·ªßa b√©: <span id="final-score">0</span></p>
              <div style="margin-top:20px;">
                  <button id="btn-restart" style="padding:10px 20px; font-size:18px; cursor:pointer; background:#4CAF50; color:white; border:none; border-radius:5px; margin-right:10px;">Ch∆°i l·∫°i</button>
                  <button id="btn-quit" style="padding:10px 20px; font-size:18px; cursor:pointer; background:#f44336; color:white; border:none; border-radius:5px;">Ch·ªçn c·∫•p ƒë·ªô</button>
              </div>
          </div>
      </div>

      <div id="math-modal" class="modal hidden">
          <div class="modal-content">
              <h2 style="color:#d84315;">üÜò C·ª©u m·∫°ng!</h2>
              <p>Tr·∫£ l·ªùi ƒë√∫ng ƒë·ªÉ ti·∫øp t·ª•c ch·∫°y:</p>
              <div id="math-question" class="question-text" style="font-size:32px; color:#333; margin:15px 0;">10 + 5 = ?</div>
              <div id="answers-container" class="answers-grid"></div>
              <div class="timer-bar" style="height:5px; background:#ddd; margin-top:10px; width:100%;"><div id="math-timer" style="height:100%; background:red; width:100%;"></div></div>
          </div>
      </div>
    </div>
    `;

    // --- Variables ---
    const canvas = container.querySelector('#gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameRunning = false;
    let frameId;
    let score = 0;
    let lives = 2; // Cho ph√©p sai 2 l·∫ßn
    let speed = GAME_SPEED;
    
    // Dino object
    const dino = { x: 50, y: 200, w: 40, h: 40, dy: 0, jumpForce: 12, ground: 200, gravity: 0.6, isJumping: false };
    
    // Obstacles
    let obstacles = [];
    let frameCount = 0;

    // Elements
    const startScreen = container.querySelector('#start-screen');
    const gameOverScreen = container.querySelector('#game-over-screen');
    const modal = container.querySelector('#math-modal');
    const scoreEl = container.querySelector('#score');
    const finalScoreEl = container.querySelector('#final-score');
    
    // Controls
    function jump() {
        if (!gameRunning) return;
        if (!dino.isJumping) {
            dino.dy = -dino.jumpForce;
            dino.isJumping = true;
        }
    }

    // Input handlers
    const keydownHandler = (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            if (!gameRunning && !gameOverScreen.classList.contains('hidden')) return; // ƒêang ·ªü m√†n h√¨nh thua th√¨ ko jump
            if (!gameRunning && startScreen) {
                startGameLoop();
            } else {
                jump();
            }
        }
    };
    const touchHandler = (e) => {
        e.preventDefault();
        if (!gameRunning && startScreen) startGameLoop();
        else jump();
    };

    document.addEventListener('keydown', keydownHandler);
    canvas.addEventListener('touchstart', touchHandler);
    canvas.addEventListener('mousedown', touchHandler);

    // N√∫t quay l·∫°i menu
    container.querySelector('#btn-back-menu').addEventListener('click', () => {
        cleanup();
        mount(container);
    });

    container.querySelector('#btn-quit').addEventListener('click', () => {
        cleanup();
        mount(container);
    });
    
    container.querySelector('#btn-restart').addEventListener('click', () => {
        resetGame();
    });

    function resetGame() {
        gameOverScreen.classList.add('hidden');
        score = 0;
        lives = 2;
        speed = GAME_SPEED;
        obstacles = [];
        dino.y = dino.ground;
        dino.dy = 0;
        updateLivesUI();
        scoreEl.textContent = '0';
        startGameLoop();
    }

    function startGameLoop() {
        gameRunning = true;
        startScreen.classList.add('hidden');
        loop();
    }

    function spawnObstacle() {
        // Random kho·∫£ng c√°ch sinh ch∆∞·ªõng ng·∫°i v·∫≠t
        const minGap = 60 - speed * 2; // T·ªëc ƒë·ªô c√†ng cao sinh c√†ng nhanh
        if (frameCount % Math.floor(1000 / speed) === 0 || Math.random() < 0.01) {
            // ƒê·∫£m b·∫£o kh√¥ng sinh qu√° g·∫ßn
            if (obstacles.length > 0) {
                const lastObs = obstacles[obstacles.length - 1];
                if (800 - lastObs.x < 250) return;
            }
            
            obstacles.push({
                x: 800,
                y: 210, // X∆∞∆°ng r·ªìng n·∫±m ƒë·∫•t
                w: 20 + Math.random() * 20,
                h: 30 + Math.random() * 20,
                color: '#4CAF50'
            });
        }
    }

    function loop() {
        if (!gameRunning) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // V·∫Ω ƒë·∫•t
        ctx.beginPath();
        ctx.moveTo(0, 240);
        ctx.lineTo(800, 240);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Dino Physics
        dino.dy += dino.gravity;
        dino.y += dino.dy;
        
        if (dino.y > dino.ground) {
            dino.y = dino.ground;
            dino.isJumping = false;
            dino.dy = 0;
        }

        // V·∫Ω Dino (H√¨nh vu√¥ng t·∫°m, sau n√†y thay ·∫£nh)
        ctx.fillStyle = '#ff5722';
        ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
        // M·∫Øt
        ctx.fillStyle = 'white';
        ctx.fillRect(dino.x + 25, dino.y + 5, 10, 10);
        ctx.fillStyle = 'black';
        ctx.fillRect(dino.x + 30, dino.y + 7, 5, 5);

        // Obstacles logic
        spawnObstacle();
        
        for (let i = 0; i < obstacles.length; i++) {
            let obs = obstacles[i];
            obs.x -= speed;
            
            // V·∫Ω X∆∞∆°ng r·ªìng
            ctx.fillStyle = obs.color;
            ctx.fillRect(obs.x, obs.y, obs.w, obs.h);

            // Va ch·∫°m
            if (
                dino.x < obs.x + obs.w &&
                dino.x + dino.w > obs.x &&
                dino.y < obs.y + obs.h &&
                dino.y + dino.h > obs.y
            ) {
                // ƒê·ª•ng tr√∫ng!
                handleCollision(i);
                return; // D·ª´ng loop ƒë·ªÉ x·ª≠ l√Ω
            }

            // Qua m·∫∑t -> TƒÉng ƒëi·ªÉm
            if (obs.x + obs.w < 0) {
                obstacles.splice(i, 1);
                i--;
                score += 10;
                scoreEl.textContent = score;
                // TƒÉng t·ªëc ƒë·ªô game theo ƒëi·ªÉm
                if (score % 100 === 0) speed += 0.5;
            }
        }

        frameCount++;
        frameId = requestAnimationFrame(loop);
    }

    function handleCollision(obsIndex) {
        gameRunning = false;
        // Hi·ªán popup to√°n h·ªçc
        generateMathQuestion(() => {
            // ƒê√∫ng: X√≥a ch∆∞·ªõng ng·∫°i v·∫≠t, ch·∫°y ti·∫øp
            obstacles.splice(obsIndex, 1);
            modal.classList.add('hidden');
            gameRunning = true;
            loop();
        }, () => {
            // Sai: M·∫•t m·∫°ng
            lives--;
            updateLivesUI();
            modal.classList.add('hidden');
            obstacles.splice(obsIndex, 1);
            
            if (lives <= 0) {
                endGame();
            } else {
                gameRunning = true;
                loop();
            }
        });
    }

    function generateMathQuestion(onCorrect, onWrong) {
        modal.classList.remove('hidden');
        const qContainer = container.querySelector('#math-question');
        const ansContainer = container.querySelector('#answers-container');
        ansContainer.innerHTML = '';

        // Random ph√©p t√≠nh theo Config
        const op = OPS[Math.floor(Math.random() * OPS.length)];
        const limit = level.config.speed > 8 ? 20 : 10; // Level kh√≥ th√¨ s·ªë to h∆°n
        const a = Math.floor(Math.random() * limit) + 1;
        const b = Math.floor(Math.random() * limit) + 1;
        let result = 0;

        if (op === '+') result = a + b;
        else if (op === '-') result = a + b; // Trick: a + b - b = a (ƒê·ªÉ ƒë·∫£m b·∫£o ph√©p tr·ª´ lu√¥n d∆∞∆°ng)
        else if (op === '*') result = a * b;
        else if (op === '/') result = a * b; // Trick: a*b / b = a

        // Hi·ªÉn th·ªã (X·ª≠ l√Ω l·∫°i ph√©p tr·ª´ v√† chia cho ƒë·∫πp)
        let displayQ = '';
        if (op === '-') { displayQ = `${a+b} - ${b} = ?`; result = a; }
        else if (op === '/') { displayQ = `${a*b} : ${b} = ?`; result = a; }
        else displayQ = `${a} ${op} ${b} = ?`;

        qContainer.textContent = displayQ;

        // T·∫°o ƒë√°p √°n
        let answers = [result, result + 1, result - 1, result + 2].filter(x => x >= 0);
        // Shuffle
        answers.sort(() => Math.random() - 0.5);
        // ƒê·∫£m b·∫£o c√≥ ƒë·ªß 4
        while(answers.length < 4) answers.push(Math.floor(Math.random()*20));
        answers = [...new Set(answers)].slice(0, 4); 

        answers.forEach(ans => {
            const btn = document.createElement('button');
            btn.className = 'answer-btn';
            btn.textContent = ans;
            btn.onclick = () => {
                if (ans === result) onCorrect();
                else onWrong();
            };
            ansContainer.appendChild(btn);
        });
    }

    async function endGame() {
        finalScoreEl.textContent = score;
        gameOverScreen.classList.remove('hidden');
        
        // T√≠nh sao
        let stars = 1;
        if (score >= 500) stars = 3;
        else if (score >= 200) stars = 2;

        const isPassed = score > 100;

        // G·ª≠i k·∫øt qu·∫£
        await submitGameResult(level.level_id, 'dino', score, stars, isPassed);
    }

    function updateLivesUI() {
        const containerL = container.querySelector('#lives-container');
        containerL.innerHTML = '';
        for(let i = 0; i < lives; i++) {
            containerL.innerHTML += '<i class="fas fa-heart"></i> ';
        }
    }
    
    // Init
    updateLivesUI();

    // Cleanup
    function cleanup() {
        gameRunning = false;
        cancelAnimationFrame(frameId);
        document.removeEventListener('keydown', keydownHandler);
        // Remove other listeners if needed
    }
    
    container._dinoCleanup = cleanup;
}

export function unmount(container) {
    if (container && container._dinoCleanup) container._dinoCleanup();
}



// export function mount(container) {
//   if (!container) return;

//   // ensure css is loaded
//   if (!document.querySelector('link[data-panel="dino-math"]')) {
//     const link = document.createElement('link');
//     link.rel = 'stylesheet';
//     link.href = './panels/dino-math/style.css';
//     link.setAttribute('data-panel','dino-math');
//     document.head.appendChild(link);
//   }

//   container.innerHTML = `
//     <div class="dino-panel">
//       <div class="game-container">
//           <div class="hud">
//               <span>ƒêi·ªÉm: <span id="score">0</span></span>
//               <div id="lives-container" class="lives-wrapper"></div>
//           </div>
//           <canvas id="gameCanvas" width="800" height="300"></canvas>

//           <div id="start-screen" class="overlay">
//               <h1>Nh·∫•n Space ƒë·ªÉ b·∫Øt ƒë·∫ßu</h1>
//           </div>
          
//           <div id="game-over-screen" class="overlay hidden">
//               <h1>THUA CU·ªòC!</h1>
//               <p>H·∫øt m·∫°ng r·ªìi. Nh·∫•n Space ƒë·ªÉ ch∆°i l·∫°i.</p>
//           </div>
//       </div>

//       <div id="math-modal" class="modal hidden">
//           <div class="modal-content">
//               <h2>C∆° h·ªôi c·ª©u m·∫°ng!</h2>
//               <p>Tr·∫£ l·ªùi ƒë√∫ng ƒë·ªÉ ti·∫øp t·ª•c, sai s·∫Ω m·∫•t 1 m·∫°ng.</p>
//               <div id="math-question" class="question-text">10 + 5 = ?</div>
//               <div id="answers-container" class="answers-grid"></div>
//           </div>
//       </div>
//     </div>
//   `;

//   // --- SELECTORS (scoped to container) ---
//   const qs = sel => container.querySelector(sel);

//   // --- KH·ªûI T·∫†O BI·∫æN (kept algorithm intact, only scoped DOM) ---
//   const canvas = qs('#gameCanvas');
//   const ctx = canvas.getContext('2d');

//   let gameRunning = false;
//   let score = 0;
//   let lives = 5;
//   let gameSpeed = 5;
//   let obstacles = [];
//   let frameId;
//   let frameCount = 0;

//   const keys = { ArrowUp: false, ArrowDown: false, Space: false };

//   const dino = {
//       x: 50,
//       y: 200,
//       originalWidth: 40,
//       originalHeight: 44,
//       duckWidth: 55,
//       duckHeight: 25,
//       width: 40,
//       height: 44,
//       dy: 0,
//       jumpPower: -8.5,
//       gravity: 0.25,
//       grounded: false,
//       isDucking: false,
//       color: '#555'
//   };

//   const obstacleConfig = { minGap: 500, groundY: 240 };

//   // Sprites (unchanged)
//   const dinoStandSprite = [
//     [0,0,0,0,0,0,1,1,1,1],
//     [0,0,0,0,0,0,1,0,1,1],
//     [0,0,0,0,0,0,1,1,1,1],
//     [0,0,0,0,0,0,1,1,1,0],
//     [1,0,0,1,1,1,1,1,0,0],
//     [1,1,1,1,1,1,1,1,1,0],
//     [0,0,1,1,1,1,1,0,0,0],
//     [0,0,1,1,1,1,1,0,0,0],
//     [0,0,1,0,0,1,0,0,0,0],
//     [0,0,1,0,0,1,0,0,0,0]
//   ];

//   const dinoDuckSprite = [
//     [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//     [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//     [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//     [0,0,0,0,0,0,1,1,1,1,0,0,0,0],
//     [1,0,0,1,1,1,1,1,1,1,1,1,1,0],
//     [1,1,1,1,1,1,1,1,1,1,1,0,1,1],
//     [0,0,1,1,1,1,1,1,1,0,0,0,0,0],
//     [0,0,1,0,0,1,0,0,0,0,0,0,0,0],
//     [0,0,1,0,0,1,0,0,0,0,0,0,0,0]
//   ];

//   const cactusSprite = [
//     [0,0,1,1,0,0],
//     [0,1,1,1,0,0],
//     [1,1,1,1,1,0],
//     [1,1,1,1,1,0],
//     [0,1,1,1,1,1],
//     [0,1,1,1,1,0],
//     [0,0,1,1,0,0],
//     [0,0,1,1,0,0],
//     [0,0,1,1,0,0],
//     [0,0,1,1,0,0]
//   ];

//   const birdSprite = [
//     [0,0,0,0,0,1,0,0],
//     [0,0,1,1,1,1,1,0],
//     [1,1,1,1,1,1,0,1],
//     [0,0,0,1,1,0,0,0]
//   ];

//   function drawPixelArt(ctx, sprite, x, y, width, height, color) {
//       ctx.fillStyle = color;
//       if (!sprite || sprite.length === 0) return;
//       const pixelW = width / sprite[0].length;
//       const pixelH = height / sprite.length;
//       for(let r = 0; r < sprite.length; r++) {
//           for(let c = 0; c < sprite[r].length; c++) {
//               if(sprite[r][c] === 1) {
//                   ctx.fillRect(x + c * pixelW, y + r * pixelH, pixelW, pixelH);
//               }
//           }
//       }
//   }

//   function updateDino() {
//       if (keys.ArrowDown) {
//           dino.isDucking = true;
//           dino.width = dino.duckWidth;
//           dino.height = dino.duckHeight;
//           if (dino.grounded) dino.y = obstacleConfig.groundY - dino.duckHeight;
//           if (!dino.grounded) dino.dy += 0.5;
//       } else {
//           dino.isDucking = false;
//           dino.width = dino.originalWidth;
//           dino.height = dino.originalHeight;
//           if (dino.grounded) dino.y = obstacleConfig.groundY - dino.originalHeight;
//       }

//       if ((keys.Space || keys.ArrowUp) && dino.grounded && !dino.isDucking) {
//           dino.dy = dino.jumpPower;
//           dino.grounded = false;
//       }

//       if (!dino.grounded) {
//           dino.dy += dino.gravity;
//           dino.y += dino.dy;
//       }

//       if (dino.y + dino.height >= obstacleConfig.groundY) {
//           dino.y = obstacleConfig.groundY - dino.height;
//           dino.dy = 0;
//           dino.grounded = true;
//       } else {
//           dino.grounded = false;
//       }
//   }

//   function spawnObstacle() {
//       let lastObsX = obstacles.length > 0 ? obstacles[obstacles.length - 1].x : 0;
//       if (obstacles.length === 0 || canvas.width - lastObsX > obstacleConfig.minGap + Math.random() * 400) {
//           const isBird = Math.random() > 0.7 && score > 3;
//           if (isBird) {
//               obstacles.push({ type: 'bird', x: canvas.width, y: 175 + Math.random() * 20, width: 40, height: 30 });
//           } else {
//               obstacles.push({ type: 'cactus', x: canvas.width, y: obstacleConfig.groundY - 50, width: 25 + Math.random() * 10, height: 40 + Math.random() * 10 });
//           }
//       }
//   }

//   function updateObstacles() {
//       for (let i = 0; i < obstacles.length; i++) {
//           let obs = obstacles[i];
//           obs.x -= gameSpeed;
//           if (obs.x + obs.width < 0) {
//               obstacles.splice(i, 1);
//               score++;
//               qs('#score').innerText = score;
//               if (score % 5 === 0) gameSpeed += 0.2;
//               i--;
//           }

//           if (
//               dino.x + 5 < obs.x + obs.width - 5 && 
//               dino.x + dino.width - 5 > obs.x + 5 &&
//               dino.y + 5 < obs.y + obs.height - 5 &&
//               dino.y + dino.height - 5 > obs.y + 5
//           ) {
//               handleCollision();
//           }
//       }
//   }

//   function drawDino() {
//       let currentSprite;
//       if (dino.isDucking) currentSprite = dinoDuckSprite;
//       else {
//           currentSprite = dinoStandSprite;
//           let tempSprite = JSON.parse(JSON.stringify(dinoStandSprite));
//           if (dino.grounded) {
//               if (Math.floor(frameCount / 10) % 2 === 0) {
//                   tempSprite[8] = [0,0,1,0,0,0,0,0,0,0];
//                   tempSprite[9] = [0,0,1,0,0,0,0,0,0,0];
//               } else {
//                   tempSprite[8] = [0,0,0,0,0,1,0,0,0,0];
//                   tempSprite[9] = [0,0,0,0,0,1,0,0,0,0];
//               }
//           }
//           currentSprite = tempSprite;
//       }
//       drawPixelArt(ctx, currentSprite, dino.x, dino.y, dino.width, dino.height, '#333');
//   }

//   function drawObstacles() {
//       obstacles.forEach(obs => {
//           if (obs.type === 'bird') {
//               let currentBird = JSON.parse(JSON.stringify(birdSprite));
//               if (Math.floor(frameCount / 15) % 2 === 0) currentBird[0] = [0,0,0,0,0,0,0,0];
//               drawPixelArt(ctx, currentBird, obs.x, obs.y, obs.width, obs.height, '#D32F2F');
//           } else {
//               drawPixelArt(ctx, cactusSprite, obs.x, obs.y, obs.width, obs.height, '#2E7D32');
//           }
//       });
//   }

//   function drawGround() {
//       ctx.beginPath();
//       ctx.moveTo(0, obstacleConfig.groundY);
//       ctx.lineTo(canvas.width, obstacleConfig.groundY);
//       ctx.strokeStyle = '#555';
//       ctx.lineWidth = 2;
//       ctx.stroke();
//       ctx.fillStyle = '#aaa';
//       for(let i=0; i<10; i++) {
//           let dotX = (frameCount * 5 + i * 100) % canvas.width;
//           if(dotX % 2 === 0) ctx.fillRect(dotX, obstacleConfig.groundY + 5 + (i%3)*4, 4, 2);
//       }
//   }

//   function gameLoop() {
//       if (!gameRunning) return;
//       frameCount++;
//       ctx.clearRect(0, 0, canvas.width, canvas.height);
//       drawGround();
//       spawnObstacle();
//       updateObstacles();
//       drawObstacles();
//       updateDino();
//       drawDino();
//       frameId = requestAnimationFrame(gameLoop);
//   }

//   // Input listeners (document-level)
//   // Use a removable named listener so we can clean up on unmount
//   const keydownListener = (e) => {
//       // NgƒÉn cu·ªôn trang
//       if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
//           e.preventDefault();
//       }

//       if (e.code === 'Space' || e.code === 'ArrowUp') keys.ArrowUp = true;
//       if (e.code === 'ArrowDown') keys.ArrowDown = true;
//       if (e.code === 'Space') keys.Space = true;

//       // --- LOGIC START GAME (ƒê√£ s·ª≠a l·ªói) ---
//       // Ki·ªÉm tra: N·∫øu game ƒëang D·ª™NG v√† kh√¥ng hi·ªán b·∫£ng t√≠nh to√°n
//       if (!gameRunning && qs('#math-modal').classList.contains('hidden')) {
//           // B·∫Øt ƒë·∫ßu l·∫°i game (Space c≈©ng kh·ªüi ƒë·ªông khi Game Over)
//           startGame();
//       }
//   };

//   function keyupHandler(e) {
//       if (e.code === 'Space' || e.code === 'ArrowUp') keys.ArrowUp = false;
//       if (e.code === 'ArrowDown') keys.ArrowDown = false;
//       if (e.code === 'Space') keys.Space = false;
//   }

//   document.addEventListener('keydown', keydownListener);
//   document.addEventListener('keyup', keyupHandler);

//   function startGame() {
//       gameRunning = true;
//       score = 0; gameSpeed = 5; lives = 5; obstacles = [];
//       qs('#score').innerText = score;
//       updateLivesUI();
//       qs('#start-screen').classList.add('hidden');
//       qs('#game-over-screen').classList.add('hidden');
//       // adapt canvas width to container width
//       canvas.width = Math.min(900, container.clientWidth - 20) || 800;
//       gameLoop();
//   }

//   function handleCollision() {
//       gameRunning = false;
//       cancelAnimationFrame(frameId);
//       showMathProblem();
//   }

//   function showMathProblem() {
//       const modal = qs('#math-modal');
//       modal.classList.remove('hidden');
//       const isAddition = Math.random() > 0.5;
//       let a = Math.floor(Math.random() * 20);
//       let b = Math.floor(Math.random() * 20);
//       if (isAddition) b = Math.floor(Math.random() * (20 - a + 1));
//       else { if (a < b) { let t=a;a=b;b=t; } }
//       const correctAnswer = isAddition ? a + b : a - b;
//       const operator = isAddition ? '+' : '-';
//       qs('#math-question').innerText = `${a} ${operator} ${b} = ?`;
//       let answers = [correctAnswer];
//       while (answers.length < 4) {
//           let wrongAnswer = Math.floor(Math.random() * 21);
//           if (!answers.includes(wrongAnswer)) answers.push(wrongAnswer);
//       }
//       answers.sort(() => Math.random() - 0.5);
//       const containerAnswers = qs('#answers-container');
//       containerAnswers.innerHTML = '';
//       answers.forEach(ans => {
//           const btn = document.createElement('button');
//           btn.innerText = ans;
//           btn.className = 'answer-btn';
//           btn.onclick = () => checkAnswer(ans, correctAnswer, btn);
//           containerAnswers.appendChild(btn);
//       });
//   }

//   function checkAnswer(userAns, correctAns, clickedBtn) {
//       const allBtns = container.querySelectorAll('.answer-btn');
//       allBtns.forEach(b => b.classList.add('disabled'));
//       let correctBtnDOM = null;
//       allBtns.forEach(b => { if (parseInt(b.innerText) === correctAns) correctBtnDOM = b; });
//       if (userAns === correctAns) {
//           clickedBtn.classList.add('correct');
//           setTimeout(() => { qs('#math-modal').classList.add('hidden'); resumeGame(); }, 1000);
//       } else {
//           clickedBtn.classList.add('wrong');
//           if (correctBtnDOM) correctBtnDOM.classList.add('correct');
//           setTimeout(() => {
//               lives--;
//               updateLivesUI();
//               qs('#math-modal').classList.add('hidden');
//               if (lives > 0) resumeGame(); else qs('#game-over-screen').classList.remove('hidden');
//           }, 1000);
//       }
//   }

//   function resumeGame() {
//       obstacles = [];
//       dino.y = 200; dino.dy = 0; dino.isDucking = false; keys.ArrowDown = false;
//       gameRunning = true;
//       gameLoop();
//   }

//   function updateLivesUI() {
//       const containerL = qs('#lives-container');
//       containerL.innerHTML = '';
//       for(let i = 0; i < 5; i++) {
//           const heart = document.createElement('span');
//           heart.innerHTML = '&#10084;';
//           heart.className = 'heart';
//           if (i < lives) heart.classList.add('active');
//           containerL.appendChild(heart);
//       }
//   }

//   // Start with initial UI
//   updateLivesUI();

//   // cleanup
//   container._dinoCleanup = () => {
//       try { document.removeEventListener('keydown', keydownListener); document.removeEventListener('keyup', keyupHandler); } catch(e){}
//       try { cancelAnimationFrame(frameId); } catch(e){}
//       delete container._dinoCleanup;
//   };
// }

// export function unmount(container) {
//   if (!container) return;
//   if (container._dinoCleanup) container._dinoCleanup();
// }
